sets

수학에서 말하는 집합

수학시간 때 배웠던 집합의 성격을 따름

여러 element들이 모여있으며, 순서가 따로 없음.

모든 element가 달라야 한다는 제약조건이 있음.

이러한 집합을 구현해놓은 것이 파이썬의 set

set은 mutable(바뀔 수 있고)하고 function arguments로 넣을 수 있음.

(클래스배웠다고 하면 말하기) set도 하나의 클래스로, (직접 보여주며) 다양한 메소드가 존재.

---

사용법

`space = {"a", "b", "c", "d", "e", "a", "b"}`

set은 중괄호로 표현, 중괄호 안에 원소들을 쉼표로 나열.

여기에 나온 space라는 set을 보면, a, b, c, d, e와 a, b가 함께 있음

(직접 타이핑) 만약 `print(space)`를 한다면, 모든 element가 달라야 한다는 제약조건에 따라 중복되는 element는 알아서 제거하는 것을 볼 수 있음. 또한 set은 순서가 상관 없는 자료구조이기에 순서가 바뀔 수도 있음.

그렇기에 순서가 중요하거나, 중복한 값이 들어가야 하는 경우에는 사용할 수 없음.

반대로, 순서가 중요하지 않거나, 중복 값이 들어가지 않는, 집합 개념을 사용해야 할 경우에 사용하면 좋음.

그렇다면

`{"a", "c", "d", "e", "b"} == {"a", "b", "c", "d", "e", "a", "b"}`의 연산을 하면 True가 나오는 것을 알 수 있음.

---

수학시간에 배웠다시피 공집합도 집합임.

공집합을 만들기 위해선 `a = set()`과 같은 방식을 사용해야 함.

직관적으로는 `a = {}`가 맞을 거 같지만, { }는 dictionary라는 다른 자료구조에서도 사용하기에 부득이하게 위의 방식을 사용함.

`a = set()`의 괄호 사이에 다른 리스트를 넣으면, 해당 리스트의 엘리머ㄴ트를 가지고 set으로 만들어줌.

`a = set(["a", "b", "c", "a",])` -> {"a", "b", "c",}

---

그리고, set에 있는 element들을 나열해서 비교한다던가, 확인한다던가, 각각의 element에 어떠한 작업을 한다던가 하기 위해 iterete 할 수도 있음.

쉽게말해서 각각의 element들을 하나씩 방문한다는 거.

```python
fruits = set(["mango", "banana", "apple"])

for element in fruits:
  print(element)
```

이 코드는, 우선 fruits를 set으로(집합으로) 선언하고,

set에 있는 각각의 element를 하나씩 element에 담고

프린트 하는 걸 반복하는 코드임.

fruits라는 set에 하나씩 접근한 것이기에 iterate 했다고 볼 수 있음.

---

메소드

set은 아래와 같은 메소드를 제공하는데, 알아둔다면 유용하게 사용 가능할 거임.

```python

num = set([1,2,3,4,5,6])
odd = set([1,3,5,7,9,11])

num.add(7)

num.add(7)
num.remove(3)
num.clear()
num.issubset(odd)

```

1 2 3 4 5 6이 들어있는 set이 있고, 1부터 11까지 들어있는 set이 있을 때, 이런 걸 할 수 있어요.

num이라는 set에 7을 add해라. 그럼 어떻게 될까요? num에 7이 추가가 되겠죠.

num이라는 set에 3을 remove해라. 그럼 어떻게 될까요?

음.. 3이라는 원소를 작제하는 건지 3번째 자리의 원소를 삭제하는 건지 애매하죠.

이 때, set의 정의를 보면 알 수 있습니다. set은 순서가 상관이 없죠. 그러기에 '3번째 자리'라는 개념 자체가 성립하지가 않아요.

그러니까 원소 3을 삭제해라가 되겠죠.

clear는 뭘까요? num이라는 set의 element를 다 지워라. 즉, 공집합으로 만들어라가 되겠죠.

is_subset은 subset인지 확인하는 function이에요. 즉, num이 odd라는 set의 subset이면, .. 부분집합이면 True가 나오고, 아니면 False가 나오죠.

반대로, is_superset이면, subset의 반대죠. 음... 초집합이라고 하나요? odds에 있는 것을 num에서 다 가지고 있을 경우 True가 나올 거예요.

difference, inter_section, union은 여러분이 수학시간에 배운 차집합, 교집합, 합집합을 return해주는 것을 의미해요.

---

mutability

mutability에 대해서 이야기 해볼게요.

set은 immutable하다고 했는데, 음..

그 전에 우선 in operator부터 볼게요.

```python
set = {1, 2, 3, 4, 5}

print(1 in set)  # True
print(6 in set)  # False
```

value in set 하면, value가 set 안에 있는지 확인하고 True 혹은 False를 뱉어줘요.

만약 여러분이 특정 value가 list 안에 있는지 없는지를 유무를 확인하는 함수를 만든다면 어떻게 만드실 건가요?

[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]라는 리스트가 있을 때, 10이라는 숫자가 존재하는지 확인하고 싶어요.

그렇다면 for문을 통해 접근하면 되겠죠.

```python
for i in list:
  if list[i] == 10:
    print(f"10은 리스트 {i}번째에 있습니다.")
```

그런데 만약. 리스트가 수백만, 수천만이라면? for문으로 도는데에만 한참이 걸려요.

```python
for i in range(1,10000000):
  print(i)
```

그렇죠?

하지만, set은 element가 수천만개가 있어도 굉장히 빠르게 접근이 가능해요.. 그건 왜 그렇냐

`해시테이블`덕분이예요.

set의 특징 -> 중복 데이터가 없고, 순서가 중요하지 않다죠.

즉, 데이터의 순서는 상관 없이 유무만 확인하면 돼요. 해당 데이터에 바로 접근할 수 있다면 확인이 되겠죠.

만약 [1, 3, 4, 7, 10] 이라는 리스트가 있으면, [1, 0, 3, 4, 0, 0, 7, 0, 0, 10]이라고 저장하면 되겠죠.

7이라는 요소가 있는지 확인하려면 리스트 전체를 도는 것이 아닌 리스트의 7번 인덱스만 확인하면 되는 거잖아요.

set도 마찬가지예요.

{"mango", "banana", "apple"}이라는 set이 있을 때,

set은 각각의 엘리먼트를 별도의 규칙을 통해서 숫자로 바꾸고, 엘리먼트들을 해당 숫자에 인덱스에 배치시켜요.

banana가 있는지 확인하겠다면, 즉, banana in set을 한다면, banana를 같은 규칙을 통해서 숫자로 변환하고, 해당 숫자를 인덱스로 가진 엘리먼트가 banana인지 확인해요. 만약 바나나라면 True를 뱉고, 아무런 값도 없으면 False를 뱉는 거죠.

그럼 이제 set의 mutability와 immutability를 논할 수 있게 됐어요.

set의 element로 들어가는 값들이 상수가 아닌, 변수라면 이러한 방식이 제대로 작동하지 않기에

set에 자체는 mutability 하지만, set에 들어가는 값들은 immutability해야하는 거예요.

```python
sets = set()
lists = [1,2,3]
sets.add(lists)
```

이 코드에서 볼 수 있다시피 set에 list를 넣으니까 작동을 안하는 것을 볼 수 있어요.

이 리스트는 언제든지 바뀔 수 있는 변수거든요.

---

예제

set이 사용되는 곳 -> 순서 상관 x, 겹치는 데이터가 없을 경우라고 했죠.

이를 반대로 생각해보면 겹치는지 확인하는 데에도 set이 잘 사용될 수 있다는 거예요.

team_A와 team_B에 둘 다 속한 사람을 찾고 싶을 때 set을 사용할 수 있겠죠.

set을 처음 사용하는 것이기에 어렵게 느껴질 수는 있겠지만, 막상 답을 보면 쉬울 거예요. 한번 각자 해볼게요.

```python
team_A = ["alice@example.com", "bob@example.com", "charlie@example.com"]
team_B = ["bob@example.com", "david@example.com", "alice@example.com"]

def common_emails(list1, list2):

    return

print(common_emails(list1, list2))
# 출력: {'alice@example.com', 'bob@example.com'}
```

```python
def common_emails(team1, team2):
    set1 = set(team1)
    set2 = set(team2)
    return set1 & set2
```

---

Tuples

set에대해 간단하게 이야기 해봤습니다.

그 다음 비슷한데 다른 튜플이라고 있어요.

튜플은 순서가 중요하다는 점에서 리스트랑 비슷해요.

대신, 리스트랑은 다르게, 오히려 set과 같이 immutable해요. 값이 바뀔 수 없는 거죠.

소괄호를 통해서 튜플을 나타낼 수 있어요.

```python

tup1 = ()
tup2 = (8,)
tup3 = (3+1,)
```

빈 튜플은 그냥 소괄호로 나타내실 수 있고, 여러 개가 있을 경우 쉼표로 나타낼 수 있습니다.

음 만약 쉼표를 넣지 않으면 튜플이 아닌, 그저 수학 식이 되어버리겠죠. 두개 이상이면 상관 없지만 하나짜리면 쉼표를 넣어줘서 이게 튜플이라는 것을 보여주는 것이 필요해요.

하나도 없을 때나, 두개 이상일 때는 상관 없고, 하나 있을 때에만 뒤에 쉼표를 붙여주시면 되겠습니다.

---

튜플은 값을 바꿀 수 없다고 했죠.

값이 한 번 들어가면 바꿀 수가 없는 거예요.

set은 각각의 엘리먼트들이 동적일 수 없다는 것이지, 값을 제거하고 다시 넣고 하는 게 가능했지만, 튜플은 엘리먼트를 추가하고 제거하는 것 마저도 불가능해요.

즉,

```python
class = ("korean", "math", "eng")
class[0] = "P.E." # SyntaxError: invalid syntax

classNgrade = (["korean", 80], ["math", 85])
classNgrade[0][1] = 90
```

이렇게 값을 수정하는 것이 안된다는 거죠.

하지만, 아래와 같이 리스트 형식으로 넣는 경우 리스트 안의 값을 바꾸는 것은 가능해요.

이를 설명하려면 메모리의 관점에서 봐야 하는데.. 음....

쉽게 설명해볼게요.

class[0] = "p.e."의 경우는 튜플의 element를 직접적으로 바꾸려 해서 오류를 내요.

튜플은 생성 시점에, 코드를 실행시키는 시점에 메모리에 고정돼요. 메모리에 튜플의 주소와 값들이 올라가고, 그 이후에는 그 메모리 위치에 있는 값을 변경할 수 없게 되죠.

이것까지는 괜찮죠. 이게 튜플의 약속이니까요.

그런데 리스트는 내부의 값을 변경할 수 있어요.

즉, 메모리에 올라간 리스트의 값을 변경하는 게 가능하죠.

튜플 안에 리스트가 있다면, 튜플은 리스트의 메모리 주소를 가지는 거고, 해당 메모리 주소에는 리스트가 있는 것이기에 리스트 내부의 element를 수정하는 게 가능해요.

그렇게 되면, 튜플 내의 리스트 자체를 바꾸는 것은 안되지만, 리스트 내의 element를 바꾸는 것은 가능하다는 것을 알 수 있죠.

음.... 처음 보면 복잡하다고 느낄 거예요. 그냥 그런갑다 하고 넘기면 될 것 같습니다. 지금 이거까지 다 이해할 필요는 없을 거 같아요.

---

다음은 dictionary입니다.

파이썬에서 상당히 자주 사용하는 자료구조인데요.

딕셔너리는 순서가 있고 mutable한 element를 중복 없이 저장하는데, 키(key)와 값(value)의 쌍으로 데이터를 저장하는 자료구조입니다.

이 때, key값은 고유해야 하며, immutable해요. value는 mutable하죠.

key값을 리스트에서의 인덱스라고 보시면 될 것 같아요.

```python
dic1 = {
  "name": "철수",
  "age": 17,
  "city": "Seoul"
}

dic2 = {
  "철수": 70,
  "영희": 90,
  "민수": 80,
}
```

위와 같은 형식을 가져요.

이 때, 딕셔너리1에서의 name, age, city와 딕셔너리2에서의 철수, 영희, 민수는 key값으로 변경되면 안될 때 딕셔너리를 사용해요.

여기서는 이름이나 라벨과 같은 것을 사용했는데

보통은 주민번호나 학번과 같이 겹칠 일이 없는 데이터들을 key값으로 사용해요.

추가로, 튜플의 특성을 보면 dictionary의 key값을 tuple로 쓸 수 있다는 것을 알 수 있는데.. 음.... 이번엔 넘어갈게요.

접근할 때에는 리스트처럼 `dic2["철수"]`와 같이 접근하면 돼요. 이러한 경우, 이러한 경우 70이 출력되겠죠.

이러한 자료구조를 자주 사용한다고 하는 이유가 뭐냐면

엑셀이나, 웹상에서 데이터를 주고 받을 때 자주 사용하는 json형식의 파일, 그리고 데이터베이스 등에서 데이터를 처리한다고 할 때,

대부분은 각 행마다 각 객체의 속성들이 있음.

예를들어 학생이 있으면, 학생 번호와 이름, 반, 중간고사 점수, 기말고사 점수 등이 하나의 레코드를 이룰 경우가 많은데,

이름이나 번호만 있어도 그 학생의 정보를 바로 찾을 수 있도록 해주는 것이 딕셔너리기 때문에 굉장히 유용하다고 볼 수 있습니다.

---
