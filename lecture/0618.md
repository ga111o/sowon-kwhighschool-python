sets

수학에서 말하는 집합

수학시간 때 배웠던 집합의 성격을 따름

여러 element들이 모여있으며, 순서가 따로 없음.

모든 element가 달라야 한다는 제약조건이 있음.

이러한 집합을 구현해놓은 것이 파이썬의 set.

참고로, 파이썬에서는 직관적으로 본다면, 순서가 존재하긴 함. 로직적인 부분에서 순서가 존재하지 않다는 거임.

추가로, set은 mutable(바뀔 수 있고)하고 function arguments로 넣을 수 있음. 이것들은 나중에 자세히 알아봄.

---

사용법

set은 중괄호로 표현, 중괄호 안에 원소들을 쉼표로 나열.

여기에 나온 my_set라는 set을 보면, 1, 2, 3, 4, 5가 있죠.
`print(my_set)`을 한다면 set 내의 element만 나오는 것이 아닌, set 형식으로 중괄호도 함께 나와요.

(직접 타이핑) 만약 `print(my_set)`를 한다면, 모든 element가 달라야 한다는 제약조건에 따라 중복되는 element는 알아서 제거하는 것을 볼 수 있음.

그렇기에 순서가 중요하거나, 중복한 값이 들어가야 하는 경우에는 사용할 수 없음.

반대로, 순서가 중요하지 않거나, 중복 값이 들어가지 않는, 집합 개념을 사용해야 할 경우에 사용하면 좋음.

참고로

`{"a", "c", "d", "e", "b"} == {"a", "b", "c", "d", "e", "a", "b"}`의 연산을 하면 True가 나오는 것을 알 수 있음.

---

`a = set()`과 같은 방식을 통해서, 즉, set 함수 내에 리스트를 넣는 방식을 통해 set을 구현할 수 있음.

`a = set()`의 괄호 사이에 다른 리스트를 넣으면, 해당 리스트의 element를 가지고 set으로 만들어줌.

`a = set(["a", "b", "c", "a",])` -> {"a", "b", "c",}

참고로 공집합도 집합이기에 `a = set()`을 통해서 공집합을 만들 수 있음.

직관적으로는 `a = {}`가 맞을 거 같지만, { }는 dictionary라는 다른 자료형에서도 사용하기에 부득이하게 위의 방식을 사용함.

그리고, set에 있는 element들을 나열해서 비교한다던가, 확인한다던가, 각각의 element에 어떠한 작업을 한다던가 하기 위해 iterete 할 수도 있음.

쉽게말해서 각각의 element들을 하나씩 방문한다는 거.

```python
fruits = set(["mango", "banana", "apple"])

for element in fruits:
  print(element)
```

이 코드는, 우선 fruits를 set으로(집합으로) 선언하고,

set에 있는 각각의 element를 하나씩 element에 담고

프린트 하는 걸 반복하는 코드임.

fruits라는 set에 하나씩 접근한 것이기에 iterate 했다고 볼 수 있음.

---

메소드

set은 아래와 같은 메소드를 제공하는데, 알아둔다면 유용하게 사용 가능할 거임.

```python

num = set([1,2,3,4,5,6])
odd = set([1,3,5,7,9,11])

num.add(7)
num.remove(3)
num.clear()
num.issubset(odd)

```

1 2 3 4 5 6이 들어있는 set이 있고, 1부터 11까지 들어있는 set이 있을 때, 이런 걸 할 수 있어요.

num이라는 set에 7을 add해라. 그럼 어떻게 될까요? num에 7이 추가가 되겠죠.

num이라는 set에 3을 remove해라. 그럼 어떻게 될까요?

음.. 3이라는 원소를 삭제하는 건지 3번째 자리의 원소를 삭제하는 건지 애매하죠.

이 때, set의 정의를 보면 알 수 있습니다. set은 순서가 상관이 없죠. 그러기에 '3번째 자리'라는 개념 자체가 성립하지가 않아요.

그러니까 원소 3을 삭제해라가 되겠죠.

clear는 뭘까요? num이라는 set의 element를 다 지워라. 즉, 공집합으로 만들어라가 되겠죠.

is_subset은 subset인지 확인하는 메서드예요. 즉, num이 odd라는 set의 subset이면, .. 부분집합이면 True가 나오고, 아니면 False가 나오죠.

반대로, is_superset이면, subset의 반대죠. 음... 초집합이라고 하나요? odds에 있는 것을 num에서 다 가지고 있을 경우 True가 나올 거예요.

difference, inter_section, union은 여러분이 수학시간에 배운 차집합, 교집합, 합집합을 return해주는 것을 의미해요.

이건 그냥 '이런 게 있었지' 하는 수준으로 기억해두면 됩니다.

억지로 외울 필요가 전혀 없어요.

필요할 때, 이런 게 있었지 하면서 찾아볼 수 있을 정도로만 알고 계시면 됩니다.

---

mutability

mutability에 대해서 이야기 해볼게요.

set은 immutable하다고 했는데,

set은 순서가 없기에 `subject[0]`과 같은 방법으로 접근이 불가능.

그 이유를 알아보기 전에 우선 in operator부터 볼게요.

```python
set = {1, 2, 3, 4, 5}

print(1 in set)  # True
print(6 in set)  # False
```

{value} in set 하면, 해당 element가 set 안에 있는지 확인하고 True 혹은 False를 뱉어줘요.

만약 여러분이 특정 element가 list 안에 있는지 없는지를 유무를 확인하는 함수를 만든다면 어떻게 만드실 건가요?

[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]라는 리스트가 있을 때, 10이라는 숫자가 존재하는지 확인하고 싶어요.

그렇다면 for문을 통해 접근하면 되겠죠.

```python
for i in list:
  if list[i] == 10:
    print(f"10은 리스트 {i}번째에 있습니다.")
```

그런데 만약. 리스트가 수백만, 수천만이라면? for문으로 도는데에만 한참이 걸려요.

```python
for i in range(1,10000000):
  print(i)
```

그렇죠?

하지만, set은 element가 수천만개가 있어도 굉장히 빠르게 접근이 가능해요.. immutable한 특징을 가지고 있어서 그래요.

자세히는 `해시테이블`덕분이예요.

set의 특징 -> '중복 데이터가 없고, 순서가 중요하지 않다'이죠.

즉, 데이터의 순서는 상관 없이 유무만 확인하면 돼요. 해당 데이터에 바로 접근할 수 있다면 확인이 되겠죠.

만약 [1, 3, 4, 7, 10] 이라는 리스트가 있으면, [0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1]이라고 저장하면 되겠죠.

7이라는 요소가 있는지 확인하려면 리스트 전체를 도는 것이 아닌 리스트의 7번 인덱스만 확인하면 되는 거잖아요.

set도 마찬가지예요.

{"mango", "banana", "apple"}이라는 set이 있을 때,

set은 각각의 엘리먼트를 별도의 규칙을 통해서 숫자로 바꾸고, 엘리먼트들을 해당 숫자에 인덱스에 배치시켜요.

banana가 있는지 확인하겠다면, 즉, banana in set을 한다면, banana를 같은 규칙을 통해서 숫자로 변환하고, 해당 숫자를 인덱스로 가진 엘리먼트가 banana인지 확인해요. 만약 바나나라면 True를 뱉고, 아무런 값도 없으면 False를 뱉는 거죠.

그럼 이제 set의 mutability와 immutability를 논할 수 있게 됐어요.

set의 element로 들어가는 값들이 immutable한 값이 아닌, mutable한 element라면 이러한 방식이 제대로 작동하지 않기에

set에 자체는 mutability 하지만, set에 들어가는 값들은 immutability해야하는 거예요.

```python
lists = [4,5,6]
sets = {1,2,3,lists}
```

이 코드에서 볼 수 있다시피 set에 list를 넣으니까 작동을 안하는 것을 볼 수 있어요.

이 리스트는 언제든지 바뀔 수 있는 변수거든요.

---

예제

set이 사용되는 곳 -> 순서 상관 x, 겹치는 데이터가 없을 경우라고 했죠.

이를 반대로 생각해보면 겹치는지 확인하는 데에도 set이 잘 사용될 수 있다는 거예요.

team_A와 team_B에 둘 다 속한 사람을 찾고 싶을 때 set을 사용할 수 있겠죠.

여러가지 방법이 있는데, and 연산을 하게 된다면 쉽게 구할 수 있어요.

방금 설명했던 개념이랑 로직을 활용하는 것이기에 set을 처음 사용한다면 어렵게 느껴질 수는 있겠지만, 막상 답을 보면 쉬울 거예요. 한번 각자 해볼게요.

```python
team_A = ["alice@example.com", "bob@example.com", "charlie@example.com"]
team_B = ["bob@example.com", "david@example.com", "alice@example.com"]

def common_emails(list1, list2):

    return

print(common_emails(list1, list2))
# 출력: {'alice@example.com', 'bob@example.com'}
```

```python
def common_emails(team1, team2):
    set1 = set(team1)
    set2 = set(team2)
    return set1 & set2
```

---

Tuples

set에대해 간단하게 이야기 해봤습니다.

그 다음 비슷한데 다른 튜플이라고 있어요.

튜플은 순서가 중요하다는 점에서 리스트랑 비슷해요.

대신, 리스트랑은 다르게, 오히려 set과 같이 immutable해요. 값이 바뀔 수 없는 거죠.

소괄호를 통해서 튜플을 나타낼 수 있어요.

---

```python

tup1 = ()
tup2 = (8,)
tup3 = (3+1,)
```

빈 튜플은 그냥 소괄호로 나타내실 수 있고, 여러 개가 있을 경우 쉼표로 나타낼 수 있습니다.

음 만약 쉼표를 넣지 않으면 튜플이 아닌, 그저 수학 식이 되어버리겠죠. 두개 이상이면 상관 없지만 하나짜리면 쉼표를 넣어줘서 이게 튜플이라는 것을 보여주는 것이 필요해요.

하나도 없을 때나, 두개 이상일 때는 상관 없고, 하나 있을 때에만 뒤에 쉼표를 붙여주시면 되겠습니다.

---

튜플은 값을 바꿀 수 없다고 했죠.

값이 한 번 들어가면 바꿀 수가 없는 거예요.

set은 각각의 엘리먼트들이 동적일 수 없다는 것이지, 값을 제거하고 다시 넣고 하는 게 가능했지만, 튜플은 엘리먼트를 추가하고 제거하는 것 마저도 불가능해요.

즉,

```python
class = ("korean", "math", "eng")
class[0] = "P.E." # SyntaxError: invalid syntax

classNgrade = (["korean", 80], ["math", 85])
classNgrade[0][1] = 90
```

이렇게 값을 수정하는 것이 안된다는 거죠.

하지만, 아래와 같이 리스트 형식으로 넣는 경우 리스트 안의 값을 바꾸는 것은 가능해요.

이를 설명하려면 메모리의 관점에서 봐야 하는데.. 음....

쉽게 설명해볼게요.

class[0] = "p.e."의 경우는 튜플의 element를 직접적으로 바꾸려 해서 오류를 내요.

튜플은 생성 시점에, 코드를 실행시키는 시점에 메모리에 고정돼요. 메모리에 튜플의 주소와 값들이 올라가고, 그 이후에는 그 메모리 위치에 있는 값을 변경할 수 없게 되죠.

이것까지는 괜찮죠. 이게 튜플의 약속이니까요.

그런데 리스트는 내부의 값을 변경할 수 있어요.

즉, 메모리에 올라간 리스트의 값을 변경하는 게 가능하죠.

튜플 안에 리스트가 있다면, 튜플은 리스트의 메모리 주소를 가지는 거고, 해당 메모리 주소에는 리스트가 있는 것이기에 리스트 내부의 element를 수정하는 게 가능해요.

그렇게 되면, 튜플 내의 리스트 자체를 바꾸는 것은 안되지만, 리스트 내의 element를 바꾸는 것은 가능하다는 것을 알 수 있죠.

음.... 처음 보면 복잡하다고 느낄 거예요. 그냥 그런갑다 하고 넘기면 될 것 같습니다. 지금 이거까지 다 이해할 필요는 없을 거 같아요.

---

다음은 dictionary입니다.

파이썬에서 상당히 자주 사용하는 자료형인데요.

딕셔너리는 순서가 있고 키(key)와 값(value)의 쌍으로 데이터를 저장하는 자료형입니다.

이 때, key값은 고유해야 하며, immutable해요. value는 mutable하죠.

딕셔너리는 이러한 형식을 가져요.

```python
dic2 = {
  "철수": 70,
  "영희": 90,
  "민수": 80,
}
```

이 때, student에서의 철수, 영희, 민수는 key값으로 변경되면 안될 때 딕셔너리를 사용해요.

여기서는 이름을 사용했는데

보통은 주민번호나 학번과 같이 겹칠 일이 없는 데이터들을 key값으로 사용해요.

key값을 리스트에서의 인덱스라고 볼 수도 있죠.

이렇게 된다면, 앞서 말했던 `해시 테이블`이라는 개념을 딕셔너리에서 명시적으로 사용했다는 것을 알 수 있어요.

추가로, 튜플의 특성을 보면 dictionary의 key값을 tuple로 쓸 수 있다는 것을 알 수 있는데.. 음.... 이번엔 넘어갈게요.

접근할 때에는 리스트처럼 `student["철수"]`와 같이 접근하면 돼요. 이러한 경우, 이러한 경우 70이 출력되겠죠.

이러한 자료형를 자주 사용한다고 하는 이유가 뭐냐면

엑셀이나, 웹상에서 데이터를 주고 받을 때 자주 사용하는 json형식의 파일, 그리고 데이터베이스 등에서 데이터를 처리한다고 할 때,

대부분은 각 행마다 각 객체의 속성들이 있음.

`223.194.20.119/9973` 참고

key만 있어도 해당 key에 있는 정보를 바로 찾을 수 있도록 해주는 것이 딕셔너리기 때문에 굉장히 유용하다고 볼 수 있습니다.

dictionary와 set 둘 다 중괄호를 사용하는데, 구분 방법은 어렵지 않아요.

{"철수": 100}과 같이 pair가 있으면 딕셔너리, 그런 게 없으면 set이라고 보시면 돼요.

`grade_dict = {}`를 통해 비어있는 딕셔너리를 만들 수 있어요. 이 때문에 set을 만들 땐 `sets = set()`이라는 메서드를 써야 했던 거고요.

`grade_dict["영희"] = 100`을 하게 된다면 영희라는 key와 100이라는 value를 가진 딕셔너리가 되겠죠.

만약 영희라는 key가 있을 경우, `grade_dict["영희"] = 80`이라고 한다면, key는 그대로 두고 100이라는 value를 80으로 고치게 됩니다.

만약 영희라는 key가 딕셔너리에 존재하는지 알고 싶다면 set과 마찬가지로 in 문법을 사용하면 됨.

`"영희" in grade_dict` 했을 때 영희가 있다면 True, 없다면 False를 뱉어줌.

앞에서 말했던 set과 마찬가지로 해시 테이블을 사용하기에 매우 빠른 속도를 보여줌. -> 정말 큰 데이터들도 빠르게 처리하기 유용해서 자주 사용함.

여기서 왜 dictionary가 set과 같이 중괄호를 사용하는지 느낌을 잡을 수 있는데,

dictionary에서 value만 없으면 set과 똑같은 것을 알 수 있음.

그래서 dictionary를 쓰고싶은데 key는 있지만 value가 딱히 필요 없을 때, value를 0이나 none과 같은 값을 주는 대신 아예 set으로 사용할 수 있음.

차이가 있다면 순서의 유무인데, 보통은 각 레코드 사이의 순서가 상관이 없기에 크게 신경쓰지 않아요.

학생이라는 딕셔너리가 있을 때, 학생 순서를 왼쪽부터 시작하나 오른쪽부터 시작하나 학생 정보가 바뀌는 건 아니잖아요.

-

만약 dictionary에 iterete하게 접근하고 싶다면 이러한 방법을 사용하시면 됩니다.

```python
student = {
  "철수": 100,
  "영희": 80,
  "민수": 90,
}

for grade in student:
  print(grade)
  print(student[grade])
```

아, 그리고 in 오퍼레이터는 key값은 찾을 수 있지만, value는 찾을 수 없어요.

```python
print(철수 in student) # True
print(100 in studnet) # False
```

이렇게요.

---

딕셔너리는 다양한 메서드가 존재해요. 이러한 메서드들을 알고 있으면 도움이 되겠죠?

물론 이를 보고 바로 활용은 어려울 거예요.

그래도 이런 게 있었지 하는 정도로도 충분하니까 한번 보도록 할게요.

```python
print(dict.keys()) # key들을 return
print(dict.values()) # value들을 return
print(dict.items()) # key - value를 튜플 형태로 return
print(dict.update("민준", 95)) # dictionary 업데이트
print(dict.pop("민준")) # 해당 key -value 삭제
print(dict.get("철수")) # 해당 key의 value return   `print(dict["철수"])` 와 같음
print(dict.clear()) # dictionary 초기화
```

---

예제: 학생의 이름과 성적이 저장된 딕셔너리에서 최고 성적을 가진 학생의 이름과 성적을 출력.

```python
students = {
  "철수": 85,
  "영희": 90,
  "민수": 98,
  "민지": 92
  }

# best_student = max(students, key=students.get) // students를 하나씩 iteration 하면서 students의 value값들 중 가장 큰 값의 key를 best_student에 저장
# best_score = students[best_student]

print(f"최고 성적 학생: { }, 성적: { }")
```
